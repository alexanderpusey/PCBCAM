<!doctype html/>
<html>
	<head>
		<title>PCBCAM</title>
	</head>
	<body style="background-color: rgb(0, 67, 129)">
		<canvas id="canvas" width=700 height=700 style="background-color: black;"></canvas>
		<textarea readonly id="text-area" style="width: 700px; height: 700px; background-color: rgb(0, 67, 129); color: white; resize: none; font-family: monospace; font-size: 15px; border: none"></textarea>
	</body>
	<script>
		const canvas = document.getElementById("canvas")
		const ctx = canvas.getContext("2d")
		const textArea = document.getElementById("text-area")
		
		json = {
			"config" : {
				"scale" : 6,
				"windowPos" : [0,0],
				"boardX" : 70.4,
				"boardY" : 101,
				"showNames" : false,
				"showPackage" : false
			},
			"devices" : [
				{
					"name" : "Resistor",
					"origin" : [10,10],
                    "package" : {
                        style : "rect",
                        dim: [4, 1],
                        offset: [0,0]
                    },
                    "points" : [
						{
							pos : [2, 0],
							drill : true,
							pad: [1.75, 1.75],
						},
                        {
                            pos : [-2, 0],
							drill : true,
							pad: [1.75, 1.75],
                        },
					],
				},
			],
			"traces" : [],
		}
		
		let devices = []

		class Device {
			constructor(index, JSONDevice) {
				this.index = index
				this.name = JSONDevice.name
                this.origin = JSONDevice.origin
				this.pk = JSONDevice.package
                this.points = JSONDevice.points
			}

            rotate() {
                json.devices[this.index].package.dim.reverse()
				json.devices[this.index].package.offset.reverse()
				for (let point of json.devices[this.index].points) {
					point.pos.reverse()
					point.pad.reverse()
				}
                render()
            }

            // convert to canvas space
            convert(coordinates, scale, windowPos=[0,0]) {
                return [
                    (coordinates[0] * scale) + windowPos[0], 
                    (coordinates[1] * scale) + windowPos[1]
                ]
            }

			draw(scale, windowPos, showNames, showPackage) {

                // origin calculation
                let cOrigin = this.convert(this.origin, scale, windowPos)
                
				// name
				if (showNames) {
					ctx.beginPath()
					ctx.font = `${1 * scale}px monospace`
					ctx.fillText(this.name, cOrigin[0], cOrigin[1])
				}

				// package/origin
				if (showPackage) {

					//origin
					ctx.fillStyle = "red"
					ctx.beginPath()
					ctx.rect(cOrigin[0], 
					cOrigin[1], 1, 1)
					ctx.fill()

					// rect package
					if (this.pk.style == "rect") {
						ctx.beginPath()
						ctx.rect(
							cOrigin[0] - (this.pk.dim[0] * 0.5 * scale), 
							cOrigin[1] - (this.pk.dim[1] * 0.5 * scale), 
							this.pk.dim[0]*scale,
							this.pk.dim[1]*scale
						)
						ctx.stroke()
					}
					// circle package
					else if (this.pk.style == "circle") {
						ctx.beginPath()
						ctx.arc(
							this.originX+this.packageOffsetX, 
							this.originY+this.packageOffsetY, 
							this.packageX*scale, 0, 2*Math.PI
						)
						ctx.stroke()
					}
				}

                // points 
                for (let point of this.points) {

					// connections
                    let cPoint = this.convert(point.pos, scale)
					ctx.fillStyle = "white"
					ctx.beginPath()
					ctx.rect(
						cOrigin[0] + cPoint[0], 
						cOrigin[1] + cPoint[1], 
						1,
						1,
					)
					ctx.fill()

					// holes
                    if (point.drill) {
                        ctx.strokeStyle = "white"
                        ctx.beginPath()
                        // 0.5 drill RADIUS
                        ctx.arc(
							cOrigin[0] + cPoint[0], 
							cOrigin[1] + cPoint[1], 
							0.5 * scale, 
							0, 
							2 * Math.PI)
                        ctx.stroke()
                    }

					//pads
					ctx.strokeStyle = "white"
					ctx.beginPath()
					ctx.rect(
						cOrigin[0] + cPoint[0] - (point.pad[0] * 0.5 * scale), 
						cOrigin[1] + cPoint[1] - (point.pad[1] * 0.5 * scale), 
						point.pad[0] * scale, 
						point.pad[1] * scale)
					ctx.stroke()
                }

			}
		}

		for (const [index, device] of json.devices.entries()) {
			devices.push(new Device(index, device))
		}

		function zoom(multiplier) {
			json.config.scale = json.config.scale * multiplier
			render()
		}

		function render() {
			// update text area to recent json
			textArea.textContent = JSON.stringify(json)
			// clears canvas
			ctx.clearRect(0, 0, canvas.width, canvas.height)

			// draws board
			ctx.strokeStyle = "red"
			ctx.beginPath()
			ctx.rect(json.config.windowPos[0], json.config.windowPos[1], json.config.boardX*json.config.scale, json.config.boardY*json.config.scale)
			ctx.stroke()

			// draws devices
			for (let device of devices) {
				device.draw(json.config.scale, json.config.windowPos,json.config.showNames, json.config.showPackage)
			}
		}

		render()
		
		// keyboard navigation
		let movementFactor = 1
		document.addEventListener("keydown", (e) => {
			switch (e.key) {
				case "ArrowUp":
					e.preventDefault()
					json.config.windowPos[1]+=movementFactor*json.config.scale
					render()
					break
				case "ArrowDown":
					e.preventDefault()
					json.config.windowPos[1]-=movementFactor*json.config.scale
					render()
					break
				case "ArrowLeft":
					e.preventDefault()
					json.config.windowPos[0]+=movementFactor*json.config.scale
					render()
					break
				case "ArrowRight":
					e.preventDefault()
					json.config.windowPos[0]-=movementFactor*json.config.scale
					render()
					break
				case "=":
					zoom(2)
					break
				case "-": 
					zoom(0.5)
					break 
				case "n":
					json.config.showNames = !json.config.showNames
					render()
					break
				case "p":
					json.config.showPackage = !json.config.showPackage
					render()
					break
			}
		})
		
	</script>
</html>
